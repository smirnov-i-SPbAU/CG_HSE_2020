#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

float4 Evaluate_SH_0_1(float3 normal)
{
    float3 c = normal.xyz * 3.0f / 4.0f / PI;
    return float4(
        c,
        1.0f / 4.0f / PI
    );
}

float4 Evaluate_SH_2(float3 normal)
{
    float4 vB = normal.xyzz * normal.yzxz;
    float3 c = vB.xyz * 15 / 4 / PI;
    return float4(
         c.x,
         c.y,
         c.z,
        (3.f * vB.w - 1.f) * 5 / 16.0f / PI
    );
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{ 
    const int THREADS = 1024;
    const int SAMPLES = 100;
    
    // See SH.shader for more details
    float4 results[7] = {
        float4(0, 0, 0, 0), // SH_0_1_r
        float4(0, 0, 0, 0), // SH_0_1_g
        float4(0, 0, 0, 0), // SH_0_1_b
        
        float4(0, 0, 0, 0), // SH_2_r
        float4(0, 0, 0, 0), // SH_2_g
        float4(0, 0, 0, 0), // SH_2_b
        
        float4(0, 0, 0, 0), // SH_2_rgb
    };

    const float const_y00 = 1.0; // 1/(2*sqrt(PI)) ** 2 * 4PI * PI / PI
    
    const float const_y1_1 = 2.0; // (-sqrt(3)/(2*sqrt(PI))) ** 2 * 4 * PI / PI * 2PI/3 
    const float const_y10 = 2.0; // (sqrt(3)/(2*sqrt(PI))) ** 2 * 4 * PI / PI * 2PI/3 
    const float const_y11 = 2.0; // (-sqrt(3)/(2*sqrt(PI))) ** 2 * 4 * PI / PI * 2PI/3 
    
    const float const_y2_2 = 15 / 4.0; // (sqrt(15)/(2*sqrt(PI)) ** 2 * 4 * PI / PI * PI / 4
    const float const_y2_1 = 15 / 4.0; // (sqrt(15)/(2*sqrt(PI)) ** 2 * 4 * PI / PI * PI / 4
    const float const_y20 = 5 / 8.0; // (sqrt(5)/(4*sqrt(PI)) ** 2 * 4 * PI / PI * PI / 4 * 2 (will be divided by 2 on shader)
    const float const_y21 = 15 / 4.0; // (sqrt(15)/(2*sqrt(PI)) ** 2 * 4 * PI / PI * PI / 4
    const float const_y22 = 15 / 16.0; // (sqrt(15)/(4*sqrt(PI)) ** 2 * 4 * PI / PI * PI / 4

    for (uint i = SAMPLES * id; i < SAMPLES * (id + 1); ++i)
    {
        float cos_theta = 2 * Random(2 * i) - 1;
        float sin_theta = sqrt(1 - cos_theta * cos_theta);
        float alpha = 2 * PI * Random(2 * i + 1);
        float3 w = float3(sin_theta * cos(alpha), sin_theta * sin(alpha), cos_theta);
        float3 color = SampleColor(w);

        float y00 = 1;
        float y1_1 = w.y;
        float y10 = w.z;
        float y11 = w.x;
        float y2_2 = w.y * w.x;
        float y2_1 = w.y * w.z;
        float y20 = 3 * w.z * w.z - 1;
        float y21 = w.x * w.z;
        float y22 = w.x * w.x - w.y * w.y;

        for (int j = 0; j < 3; ++j)
        {
            results[j].x += y11 * color[j];
            results[j].y += y1_1 * color[j];
            results[j].z += y10 * color[j];
            results[j].w += y00 * color[j];
        }

        for (int k = 0; k < 3; ++k)
        {
            results[k + 3].x += y2_2 * color[k];
            results[k + 3].y += y2_1 * color[k];
            results[k + 3].z += y21 * color[k];
            results[k + 3].w += y20 * color[k];
        }
        results[6].x += y22 * color[0];
        results[6].y += y22 * color[1];
        results[6].z += y22 * color[2];
    }

    for (int result_id = 0; result_id < 7; ++result_id)
    {
        results[result_id] /= SAMPLES;
    }

    for (int j = 0; j < 3; ++j)
    {
        results[j].x *= const_y11;
        results[j].y *= const_y1_1;
        results[j].z *= const_y10;
        results[j].w *= const_y00;
    }
    
    for (int k = 0; k < 3; ++k)
    {
        results[k + 3].x *= const_y2_2;
        results[k + 3].y *= const_y2_1;
        results[k + 3].z *= const_y21;
        results[k + 3].w *= const_y20;
    }
    results[6] *= const_y22;
    
    // TASK: project light from _Env to spherical harmonic coefficients and store them in results[]
    for (int i = 0; i < SAMPLES; i++)
    {
        uint seed = THREADS * id + i;
        float u = Random(2 * seed);
        float v = Random(2 * seed + 1);
        float phi = u * TWO_PI;
        float cosTheta = 2 * v - 1;
        float sinTheta = sqrt(1 - cosTheta * cosTheta);
        
        float3 sampleDir = float3(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta
        );
    
        float3 sample = SampleColor(sampleDir);
        
        float4 sh_0_1 = Evaluate_SH_0_1(sampleDir);
        sh_0_1.w *= PI;
        sh_0_1.xyz *= 2 * PI / 3;
        for (int c = 0; c < 3; c++)
        {
            results[c] += sample[c] * sh_0_1;
        }
        
        float4 sh_2 = Evaluate_SH_2(sampleDir);
        sh_2 *= PI / 4;
        
        for (c = 0; c < 3; c++)
        {
            results[3 + c] += sample[c] * sh_2;
        }
        
        results[6].rgb += sample * 15 / 16 / PI * (sampleDir.x*sampleDir.x - sampleDir.y*sampleDir.y);
        results[6].rgb *= PI / 4;
    }
    
    for (i = 0; i < 7; i++)
    {
        results[i] = results[i] * 4 / SAMPLES;
    }
    
    //for (int c = 0; c < 3; c++)
    //{
    //    // Precomputing coefficients of max(0, cos(theta) for L=0
    //    results[c].w *= PI; 
    //    // Precomputing coefficients of max(0, cos(theta) for L=1
    //    results[c].xyz *= PI * 2 / 3;
    //}
    //
    //for (c = 0; c < 4; c++)
    //{
    //    // Precomputing coefficients of max(0, cos(theta) for L=2
    //    results[3 + c] *= PI / 4;
    //} 
    
    //for (int c = 0; c < 7; c++) 
    //{
    //    results[c] *= PI * 4;
    //}
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
    
    SH_2_rgb[id] = results[6];    
}
