// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ComputeHarmonics

#define PI            3.14159265359f
#define TWO_PI        6.28318530718f
#define FOUR_PI       12.56637061436f
#define INV_PI        0.31830988618f
#define INV_TWO_PI    0.15915494309f
#define INV_FOUR_PI   0.07957747155f
#define HALF_PI       1.57079632679f
#define INV_HALF_PI   0.636619772367f

RWStructuredBuffer<float4> SH_0_1_r;
RWStructuredBuffer<float4> SH_0_1_g;
RWStructuredBuffer<float4> SH_0_1_b;

RWStructuredBuffer<float4> SH_2_r;
RWStructuredBuffer<float4> SH_2_g;
RWStructuredBuffer<float4> SH_2_b;

RWStructuredBuffer<float4> SH_2_rgb;

TextureCube<half4> _Env;
SamplerState samplerLinearRepeat;

uint Hash(uint s)
{
    s ^= 2747636419u;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    s ^= s >> 16;
    s *= 2654435769u;
    return s;
}

float Random(uint seed)
{
    return float(Hash(seed)) / 4294967295.0; // 2^32-1
}

float3 SampleColor(float3 direction)
{   
    float4 tex = _Env.SampleLevel(samplerLinearRepeat, direction, 0);
    return tex.rgb;
}

[numthreads(1024, 1, 1)]
void ComputeHarmonics(uint id : SV_DispatchThreadID)
{
    const int THREADS = 1024;
    const int SAMPLES = 100;
    
    // See SH.shader for more details
    float4 results[7] = {
        float4(0, 0, 0, 0), // SH_0_1_r
        float4(0, 0, 0, 0), // SH_0_1_g
        float4(0, 0, 0, 0), // SH_0_1_b
        
        float4(0, 0, 0, 0), // SH_2_r
        float4(0, 0, 0, 0), // SH_2_g
        float4(0, 0, 0, 0), // SH_2_b
        
        float4(0, 0, 0, 0), // SH_2_rgb
    };

    const float SQRT_PI_2_INV = 1.0 / 2 * sqrt(PI);

    for (uint i = SAMPLES * id; i < SAMPLES * (id + 1); ++i)
    {
        float cos_theta = 2 * Random(2 * i) - 1;
        float sin_theta = sqrt(1 - cos_theta * cos_theta);
        float alpha = 2 * PI * Random(2 * i + 1);
        float3 w = float3(sin_theta * cos(alpha), sin_theta * sin(alpha), cos_theta);
        float3 color = SampleColor(w);

        float y00 = SQRT_PI_2_INV;
        float y1_1 = -sqrt(3) * w.y * SQRT_PI_2_INV;
        float y10 = sqrt(3) * w.z * SQRT_PI_2_INV;
        float y11 = -sqrt(3) * w.x * SQRT_PI_2_INV;
        float y2_2 = sqrt(15) * w.y * w.x * SQRT_PI_2_INV;
        float y2_1 = -sqrt(15) * w.y * w.z * SQRT_PI_2_INV;
        float y20 = sqrt(5) * (3 * w.z * w.z - 1) * SQRT_PI_2_INV / 2;
        float y21 = -sqrt(15) * w.x * w.z * SQRT_PI_2_INV;
        float y22 = sqrt(15) * (w.x * w.x - w.y * w.y) * SQRT_PI_2_INV / 2;

        for (int j = 0; j < 3; ++j)
        {
            results[j].x += y1_1 * color[j];
            results[j].y += y10 * color[j];
            results[j].z += y11 * color[j];
            results[j].w += y00 * color[j];
        }

        for (int k = 0; k < 3; ++k)
        {
            results[k + 3].x += y2_2 * color[k];
            results[k + 3].y += y2_1 * color[k];
            results[k + 3].z += y21 * color[k];
            results[k + 3].w += y20 * color[k];
        }
        results[6] += y22 * float4(color, 0.0);
    }

    for (int result_id = 0; result_id < 7; ++result_id)
    {
        results[result_id] /= SAMPLES;
    }
    
    // Populate results buffer using monte-carlo method.
    // You can see the Random(i) function. Use it just as with the previous task.
    
    // TASK: project light from _Env to spherical harmonic coefficients and store them in results[]
    
    SH_0_1_r[id] = results[0];
    SH_0_1_g[id] = results[1];
    SH_0_1_b[id] = results[2];
    
    SH_2_r[id] = results[3];
    SH_2_g[id] = results[4];
    SH_2_b[id] = results[5];    
    
    SH_2_rgb[id] = results[6];
}
